
496. Next Greater Element I
503. Next Greater Element II
739. Daily Temperatures
901. Online Stock Span
907. Sum of Subarray Minimums
84. Largest Rectangle in Histogram
42. Trapping Rain Water


1130. Minimum Cost Tree From Leaf Values
856. Score of Parentheses

1019
1441
5
414

### 496. 下一个更大元素 I
暴力解法就是根据num1的值，去num2遍历，就是O(n^2)
我们可以先不管nums1，就去nums2中对每个元素求下一个更大，然后把答案放hashmap中，让nums1来找
假如1，3，4，2
可以这样，维护一个单调递减（包括相同）的栈，再加一个map来记录各自对应的更大值。
遍历数组，如果比栈内的数小，就加进去，否则，栈内的全出栈(错啦！是栈内小于当前这个数的出栈！)，把当前这个数字当作更大值，记录进map里。然后把当前这个值入栈。


### 503. 下一个更大元素 II
循环数组的下一个更大元素。
比之不循环的下一个更大（496），应该是循环两次数组就可以了
但是要注意一个细节，它跟非循环的差别是，不同位置上相同的数，他们的下一个更大是不一样的。
所以就用下面的。
维护一个单调递减的栈，
循环nums里的数：num，循环跟栈顶的元素比，如果num大，证明栈里已经有的元素他们的结果都是当前这个数。
也就是说把栈里的小于num的数全部取出来，这些都是已经找到结果的。把他们记录下来。然后再把num放进去。
但是有一个问题是，你取出栈里的数，但是怎么直到要把他们的结果放在结果数组里的哪一个位置。
所以这里用的方法是，在栈里放的是idx。


### 739. 每日温度
也就是要找到下一个更大的跟自己之间的距离。如果没找到就是0。
可以维护一个单调栈，然后里面放index。


### 901. 股票价格跨度
主要是一个状态的折叠。
新的元素加入的时候，我怎么才能知道前面比我小的还有多少。
最朴素的是直接遍历。
而能够折叠的是，如果一个数小于我，那小于它的数肯定也小于我。
用这种思路来折叠，可以节省一些。





### 42. 接雨水



































