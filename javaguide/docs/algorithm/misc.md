### 剑指 Offer 48. 最长不含重复字符的子字符串
首先，看到“最长”字样，有可能跟动态规划有关。
分析题目，从暴力解入手。
假设解是(i,j)，也就是说其他的字符串在(i,j)种肯定出现，并且(i,j)完全不重复，并且找不到比(i,j)更长的满足条件的解
可以用状态变量int dp[][]来表示以i，j为两端的，最长的无重复子字符串的长度。
但是这样的话，f(i,j) 和 f(i,j-1)的关系，其实是没办法确定的。
所以换一种用boolean dp[][]来表示以i，j为两端的，是不是无重复的字符串。这样结果可以由遍历所有true的，取出j-i最大的数
然后f(i,j+1) = j+1的字符去查看是不是跟i，j的字符有重复，有就是false，没有就是true
=========以上这个方法在字符串非常大的时候会超出内存限制
所以要考虑状态压缩的问题
其实f(i,j)只需要f(i,j-1)的状态，并且这个状态是没有断层的，完全可以压缩成只记两个状态就行了。
这个方法通过倒是通过了。但是时间复杂度只击败5%
应该还有更好的办法，就是用hashset来保存前面的字符，来做重复的判断。
只不过是，这个hashset的状态跟distinct一样，是一直要去维护改变的。
==========用了hashset竟然也只是击败5%！
看了题解的方法，它做了一个优化，就是如果发现是有重复的，其实下一个start的索引就得从当前idx开始了。（错误）
是从找到的之前的那个重复的索引的下一个位置。
因为start从之前开始的，都不可能是最优解了。
还有一个优化点是，可以直接维护一个(char，idx)的hashmap，
这样通过找当前这个char在hashmap中的idx，其实就可以逆向推出，跟之前的那个子串是不是完全不重复
并且这里还不用记录上一个相邻的子串是重复还是不重复的。
相当于一个是正着推，一个是反着推。
这么说也不准确。应该是说，它是直接每次都去找不重复的。
根本不会去记录那些重复的。
============
总结一下，就是动态规划的状态压缩吧总体来说。
其实它是双指针。只是说双指针太custom了。不够思路统一。





