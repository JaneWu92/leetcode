
## 数组，双指针
### 15. 三数之和
* 三重循环一下搞定，时间复杂度N^3
* 这个时间复杂度呢，已经可以做随便找3个数，这件事情。但是本题中，三个数字之间是有关系的，和的关系。
* 所以如果用上面这个算法，是浪费了这个“和”的信息。
* 然后我们就来看这个“和”的信息怎么样能够利用起来。
* 先把第一重的固定下来，然后第二重第三重分别从最左最右开始，因为一个只能增，一个只能减，它的移动的规律就很明显了。直到他们相撞前能碰见彼此。
* 还有一点是避免重复。就是第一重和第二重，如果和之前一样，就不用再写了
```aidl

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        if(n < 3) return list;
        for(int i = 0; i< n-2; i++){
            // 这里是为了避免重复
            // 像 2，2，。。。。第二个2解出来的解，肯定是第一个2已经解过了的。毋庸置疑。是子集，所以不用管
            if(i>0 && nums[i] == nums[i-1]) continue;
            int left = i+1, right = n-1, sum = 0-nums[i];
            while(left < right){
                // 如果sum same，就加进list里，然后再left++, right--继续
                // 如果sum大，left++继续
                // 如果sum小，right--继续
                if(left != i+1 && nums[left] == nums[left-1]){
                    left++;
                    continue;
                }
                int tmp = nums[left] + nums[right];
                if(tmp == sum){
                    Integer[] arr = new Integer[]{nums[i], nums[left], nums[right]};
                    List<Integer> l = new ArrayList<Integer>(Arrays.asList(arr));
                    list.add(l);
                    left++;
                    right--;
                }else if(sum > tmp){
                    left++;
                }else if(sum < tmp){
                    right--;
                }
            }
        }
        return list;
    }
}
```

### 11. 盛最多水的容器
暴力解法是，算出所有组合。
n条线。Cn2，数量是n(n-1)/2
也就是说时间复杂度是n^2
改进：
这题的关键点是在于，缩小搜索空间。
举例子：[1,8,6,2,5,4,8,3,7]
最初左右指针是在两端。然后res = (j - i) * min(array[i], array[j])
然后，我们要去找有可能更大的，因为底长现在是最大，所以说，一定要找min(array[i], array[j])更大的。
所以只能是往内移动比较短的那根。然后后面就按照一样的思路。继续。
问题1： 
在某一个节点，i，j，为什么我不能选择外扩，只能选择内缩。
这个比较不好解释，先理解为，我就是从最外面进来的吧
问题2：
这样一直收缩，能保证不错过更优解吗。
这个也不好回答。
总体思路：
两两比较取max

### 16. 最接近的三数之和
先把数组排序
a+b+c + (-res) 绝对值最小
a+b -c+res 绝对值最小
我们可以先定下右边的，假说是k，然后左边的范围就是i，j可能的区间。
如果结果大于零就右边的往左缩，反之就左边往右扩


### 86. 分隔链表
这个不是遍历一遍，然后高低位拆开，然后最后低位尾接高位头，就好了吗

### 18. 四数之和
先固定第四位，然后就变成三数之和了。
要注意的一点是，怎么去除重复的的四元组。
我觉得在出结果的时候去重把，前面去重的话考虑的因素太多了。
====错误。这里去重采取的方法应该是说，在每一层里，如果后面一个可能性跟现在这个的数字是一样的，就跳过。
因为，你是人家的子集，肯定被收集过了的。


















