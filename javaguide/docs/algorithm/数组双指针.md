
## 数组，双指针
### 15. 三数之和
* 三重循环一下搞定，时间复杂度N^3
* 这个时间复杂度呢，已经可以做随便找3个数，这件事情。但是本题中，三个数字之间是有关系的，和的关系。
* 所以如果用上面这个算法，是浪费了这个“和”的信息。
* 然后我们就来看这个“和”的信息怎么样能够利用起来。
* 先把第一重的固定下来，然后第二重第三重分别从最左最右开始，因为一个只能增，一个只能减，它的移动的规律就很明显了。直到他们相撞前能碰见彼此。
* 还有一点是避免重复。就是第一重和第二重，如果和之前一样，就不用再写了
```aidl

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        if(n < 3) return list;
        for(int i = 0; i< n-2; i++){
            // 这里是为了避免重复
            // 像 2，2，。。。。第二个2解出来的解，肯定是第一个2已经解过了的。毋庸置疑。是子集，所以不用管
            if(i>0 && nums[i] == nums[i-1]) continue;
            int left = i+1, right = n-1, sum = 0-nums[i];
            while(left < right){
                // 如果sum same，就加进list里，然后再left++, right--继续
                // 如果sum大，left++继续
                // 如果sum小，right--继续
                if(left != i+1 && nums[left] == nums[left-1]){
                    left++;
                    continue;
                }
                int tmp = nums[left] + nums[right];
                if(tmp == sum){
                    Integer[] arr = new Integer[]{nums[i], nums[left], nums[right]};
                    List<Integer> l = new ArrayList<Integer>(Arrays.asList(arr));
                    list.add(l);
                    left++;
                    right--;
                }else if(sum > tmp){
                    left++;
                }else if(sum < tmp){
                    right--;
                }
            }
        }
        return list;
    }
}
```

### 11. 盛最多水的容器
暴力解法是，算出所有组合。
n条线。Cn2，数量是n(n-1)/2
也就是说时间复杂度是n^2
改进：
这题的关键点是在于，缩小搜索空间。
举例子：[1,8,6,2,5,4,8,3,7]
最初左右指针是在两端。然后res = (j - i) * min(array[i], array[j])
然后，我们要去找有可能更大的，因为底长现在是最大，所以说，一定要找min(array[i], array[j])更大的。
所以只能是往内移动比较短的那根。然后后面就按照一样的思路。继续。
问题1： 
在某一个节点，i，j，为什么我不能选择外扩，只能选择内缩。
这个比较不好解释，先理解为，我就是从最外面进来的吧
问题2：
这样一直收缩，能保证不错过更优解吗。
这个也不好回答。
总体思路：
两两比较取max

### 16. 最接近的三数之和
先把数组排序
a+b+c + (-res) 绝对值最小
a+b -c+res 绝对值最小
我们可以先定下右边的，假说是k，然后左边的范围就是i，j可能的区间。
如果结果大于零就右边的往左缩，反之就左边往右扩


### 86. 分隔链表
这个不是遍历一遍，然后高低位拆开，然后最后低位尾接高位头，就好了吗

### 18. 四数之和
先固定第四位，然后就变成三数之和了。
要注意的一点是，怎么去除重复的的四元组。
我觉得在出结果的时候去重把，前面去重的话考虑的因素太多了。
====错误。这里去重采取的方法应该是说，在每一层里，如果后面一个可能性跟现在这个的数字是一样的，就跳过。
因为，你是人家的子集，肯定被收集过了的。




### 剑指 Offer 48. 最长不含重复字符的子字符串
首先，看到“最长”字样，有可能跟动态规划有关。
分析题目，从暴力解入手。
假设解是(i,j)，也就是说其他的字符串在(i,j)种肯定出现，并且(i,j)完全不重复，并且找不到比(i,j)更长的满足条件的解
可以用状态变量int dp[][]来表示以i，j为两端的，最长的无重复子字符串的长度。
但是这样的话，f(i,j) 和 f(i,j-1)的关系，其实是没办法确定的。
所以换一种用boolean dp[][]来表示以i，j为两端的，是不是无重复的字符串。这样结果可以由遍历所有true的，取出j-i最大的数
然后f(i,j+1) = j+1的字符去查看是不是跟i，j的字符有重复，有就是false，没有就是true
=========以上这个方法在字符串非常大的时候会超出内存限制
所以要考虑状态压缩的问题
其实f(i,j)只需要f(i,j-1)的状态，并且这个状态是没有断层的，完全可以压缩成只记两个状态就行了。
这个方法通过倒是通过了。但是时间复杂度只击败5%
应该还有更好的办法，就是用hashset来保存前面的字符，来做重复的判断。
只不过是，这个hashset的状态跟distinct一样，是一直要去维护改变的。
==========用了hashset竟然也只是击败5%！
看了题解的方法，它做了一个优化，就是如果发现是有重复的，其实下一个start的索引就得从当前idx开始了。（错误）
是从找到的之前的那个重复的索引的下一个位置。
因为start从之前开始的，都不可能是最优解了。
还有一个优化点是，可以直接维护一个(char，idx)的hashmap，
这样通过找当前这个char在hashmap中的idx，其实就可以逆向推出，跟之前的那个子串是不是完全不重复
并且这里还不用记录上一个相邻的子串是重复还是不重复的。
相当于一个是正着推，一个是反着推。
这么说也不准确。应该是说，它是直接每次都去找不重复的。
根本不会去记录那些重复的。
============
总结一下，就是动态规划的状态压缩吧总体来说。
其实它是双指针。只是说双指针太custom了。不够思路统一。



















