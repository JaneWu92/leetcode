
## 数组，双指针
### 15. 三数之和
* 三重循环一下搞定，时间复杂度N^3
* 这个时间复杂度呢，已经可以做随便找3个数，这件事情。但是本题中，三个数字之间是有关系的，和的关系。
* 所以如果用上面这个算法，是浪费了这个“和”的信息。
* 然后我们就来看这个“和”的信息怎么样能够利用起来。
* 先把第一重的固定下来，然后第二重第三重分别从最左最右开始，因为一个只能增，一个只能减，它的移动的规律就很明显了。直到他们相撞前能碰见彼此。
* 还有一点是避免重复。就是第一重和第二重，如果和之前一样，就不用再写了
```aidl

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        if(n < 3) return list;
        for(int i = 0; i< n-2; i++){
            // 这里是为了避免重复
            // 像 2，2，。。。。第二个2解出来的解，肯定是第一个2已经解过了的。毋庸置疑。是子集，所以不用管
            if(i>0 && nums[i] == nums[i-1]) continue;
            int left = i+1, right = n-1, sum = 0-nums[i];
            while(left < right){
                // 如果sum same，就加进list里，然后再left++, right--继续
                // 如果sum大，left++继续
                // 如果sum小，right--继续
                if(left != i+1 && nums[left] == nums[left-1]){
                    left++;
                    continue;
                }
                int tmp = nums[left] + nums[right];
                if(tmp == sum){
                    Integer[] arr = new Integer[]{nums[i], nums[left], nums[right]};
                    List<Integer> l = new ArrayList<Integer>(Arrays.asList(arr));
                    list.add(l);
                    left++;
                    right--;
                }else if(sum > tmp){
                    left++;
                }else if(sum < tmp){
                    right--;
                }
            }
        }
        return list;
    }
}
```