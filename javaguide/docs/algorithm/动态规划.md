669 coin change -> lintcode

### 53. 最大子序和
具有最大和的连续子数组
f(n) = max(f(n-1), a[n])  -> 错误，人家要的是**连续**的的数组
f(n)表示的是n个数中，最大的连续子数组和。而不是以n结尾的，最大的子数组和
f(n)应该是等于，包含以n为结尾的，和不包含以n为结尾的里面，比较大的那个。
但是因为要是连续的，怎么判断f(n-1)到底取了以n-1为结尾，还是没取呢。
==========分隔符
因为以上状态无法确定，所以我们要换一个思路。
f(n)用来表示以n为结尾的，最大的子数组和。
然后最后的答案就是max(dp[i])
f(n) = max(a[n], a[n]+f(n-1))


### 300. 最长上升子序列
最长的上升子序列。不用连续
f(n)代表以n为结尾并且包含n的最长子序列的长度。
f(n) = max(f(i))+1 a[i]<a[n]
答案是dp的最大


### 673. 最长递增子序列的个数
维护长度和个数这两个状态。
f(n)代表以n为结尾的递增子序列。
f(n) = 
（f(n-1..i..0)中长度最长的递增子序列，并且a[n]>a[i]）
然后长度加上 pre,个数不变。

这里面有一个重要的点是，重复的问题。
在求（f(n-1..i..0)中长度最长的递增子序列，并且a[n]>a[i]）的时候
如果有更长，就reset这个count变成1
如果是跟当前相等，那是在本来的count上加1（请注意，不是1，应该是dp之前状态的count）


### 354. 俄罗斯套娃信封问题
最多能有多少个信封形成套娃
f(n)是以n为最后一个信封的套娃数量
f(n)等于1+ 前面所有比他小的数量的最大值
哦这题的一个难点是，不计较顺序。
所以我觉得可以先按width排序一下，再做。


### 152. 乘积最大子数组
乘积最大连续子数组
f(n) = max(f(n-1)*a[n], a[n])
这个问题有点不一样，f(n)不能由f(n-1)推出来。
====因为有正负，所以没有最优子结构
所以每一个都要保留两个状态，最大和最小。
因为都有可能对结果有贡献


### 918. 环形子数组的最大和
应该是两倍的当前数组组成一个新数组，然后再做一样的操作
abcde abcde
f(n)是max(a[n], f(n-1))
应该是从第2个N开始算，就是第二个abcde
Kadane算法：不确定具体步骤
但是这里有一个是说，如果这个最大和是跨数组的，
那它被环留下的子数组，会是不跨数组的最小和。不知道是为什么

### 面试题 17.24. 最大子矩阵
应该是把一维的变成二维的了。
是最大和子序列的升维版本。
？？？


### 198. 打家劫舍
相邻的房屋是不能偷的。
也就是每个位置都存在两种可能，能偷或者不能，并且这个结果会影响到下一个的结果
f(n)代表的是以当前这个位置为结尾的最高的收入。
f(n)是由a[n]+ Max(f(n-2 ... i ..0))
===========
有问题啊。这里好像可以是另外一种思路。
就是f(i)是代表对于前i间房偷窃的最好方案。
它包括两种：
第i间要偷：f(i) = a[i] + f(i-2)
第i间不偷: f(i) = f(i-1)
所以f(i) = max(上面两者)
===========
好像这种问题以上两个选择都是可以的。但是具体如何区分，待查


### 213. 打家劫舍 II
房屋围成一圈。
也就是说第一个和最后一个，只能偷窃一个。
可以按照单排的来算。
然后选最大的，最后一个和第一个没有一起出现过的。
但是它会恰巧包含我们想要的解吗，就是第一和最后不重复出现
我觉得未必。因为按照我们的做法，得出的结果是，以n为结尾的，最大的选择。选择只有一个，要么带1，要么不带1。
所以我觉得其实可以在f最后一个的时候，显式的去掉以1为结尾的。
但是也是不对的，因为我们要排除的，不是以1为结尾的，是包含1的。
所以要用另外的思路。
分成三类：有1无尾，无1有尾，无1无尾
在其中选最大，应该就对了。
但是这里面有可以优化的部分吗。感觉相同的做三次有点傻（写个子函数不就行了。。）。


### 740. 删除与获得点数
居然是打家劫舍的变种。太隐蔽了。
新建数组，把数字记录在数组下标的信息上。
新数组的a[i]，表示的是原数组上i出现的个数。
题目变成，新数组相邻的数字不能选，然后计算最大的字串和。
这个和是i*a[i]的和。
===========
参考上面打家劫舍


### 1388. 3n 块披萨
这题就是循环打家劫舍的变种。
但是打家劫舍只是相邻的不能选
这里的也是相邻的不能选。并且在可选总数上是有限制的。
因为其实所有东西是三个人分。
。。。。以后再看


### 873. 最长的斐波那契子序列的长度
https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/
这个题目
最优子结构是，f(i) = 1 + f(<i)所有的最大，并且，a[i]=子结构里最后两个数的和
怎么保存这个状态。dp[][]，两个数，保留数组的下一个，和这个数组的长度
===========
这里有一个问题，就是这个最优子结构，只能保持一个序列，但是可能有很多序列都是一样的长度，但是有机会和现在这个组成更长的，被丢弃了。
所以这个方法是不行的。
===========
dp[(3,5)], dp[(2,3)]
这个就是所谓的要记录两个状态。
这里的重点就是，要有两个数，才能准确锚定一个斐波那契子序列。


### 1027. 最长等差数列
https://leetcode-cn.com/problems/longest-arithmetic-subsequence/
















