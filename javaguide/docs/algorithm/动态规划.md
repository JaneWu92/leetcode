669 coin change -> lintcode

### 53. 最大子序和
具有最大和的连续子数组
f(n) = max(f(n-1), a[n])  -> 错误，人家要的是**连续**的的数组
f(n)表示的是n个数中，最大的连续子数组和。而不是以n结尾的，最大的子数组和
f(n)应该是等于，包含以n为结尾的，和不包含以n为结尾的里面，比较大的那个。
但是因为要是连续的，怎么判断f(n-1)到底取了以n-1为结尾，还是没取呢。
==========分隔符
因为以上状态无法确定，所以我们要换一个思路。
f(n)用来表示以n为结尾的，最大的子数组和。
然后最后的答案就是max(dp[i])
f(n) = max(a[n], a[n]+f(n-1))


### 300. 最长上升子序列
最长的上升子序列。不用连续
f(n)代表以n为结尾并且包含n的最长子序列的长度。
f(n) = max(f(i))+1 a[i]<a[n]
答案是dp的最大


### 673. 最长递增子序列的个数
维护长度和个数这两个状态。
f(n)代表以n为结尾的递增子序列。
f(n) = 
（f(n-1..i..0)中长度最长的递增子序列，并且a[n]>a[i]）
然后长度加上 pre,个数不变。

这里面有一个重要的点是，重复的问题。
在求（f(n-1..i..0)中长度最长的递增子序列，并且a[n]>a[i]）的时候
如果有更长，就reset这个count变成1
如果是跟当前相等，那是在本来的count上加1（请注意，不是1，应该是dp之前状态的count）


### 354. 俄罗斯套娃信封问题
最多能有多少个信封形成套娃
f(n)是以n为最后一个信封的套娃数量
f(n)等于1+ 前面所有比他小的数量的最大值
哦这题的一个难点是，不计较顺序。
所以我觉得可以先按width排序一下，再做。


### 152. 乘积最大子数组
乘积最大连续子数组
f(n) = max(f(n-1)*a[n], a[n])
这个问题有点不一样，f(n)不能由f(n-1)推出来。
====因为有正负，所以没有最优子结构
所以每一个都要保留两个状态，最大和最小。
因为都有可能对结果有贡献


### 918. 环形子数组的最大和
应该是两倍的当前数组组成一个新数组，然后再做一样的操作
abcde abcde
f(n)是max(a[n], f(n-1))
应该是从第2个N开始算，就是第二个abcde
Kadane算法：不确定具体步骤
但是这里有一个是说，如果这个最大和是跨数组的，
那它被环留下的子数组，会是不跨数组的最小和。不知道是为什么


















