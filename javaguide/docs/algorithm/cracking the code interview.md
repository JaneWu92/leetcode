## 01

### 01.01. 判定字符是否唯一
一个是hashset直接
一个是把char排序，然后遍历
但是这两个都用到了库函数
好的做法是，利用ascii只有128个的限制
遍历数组，看是128个中的哪一个，并且做记录
这样能发现重复，并且，时间复杂度只有26n，也就是n
实现：
1. boolean 数组
2. 位运算。用两个long来装。
    每个char的值就是1左移char的int值位。
    判断有没有在，用&，没在的话放进去，用|
    
### 01.02. 判定是否互为字符重排
可以用128长度的int数组，来存放各个字符出现的次数。
然后做比较。

### 01.03. URL化
这题审题都审得有点够呛。
就是给了一个字符串，还有一个长度，这个长度自称是这个字符串的“真实”长度。
做的话可以先计算出整个的长度，然后从后往前放。


### 01.04. 回文排列
字符出现次数单数的只有1或0。

### 01.05. 一次编辑
从左往右遍历，比较current c1, current c2
出现相同就继续，
不同的话：
    插入：nxt c2要跟cur c1一样
    删除：cur c2要跟nxt c1一样
    替换：nxt c2要跟nxt c1不一样
这个思路的问题是，你只比较了前面的一样，没比较后面的一样。
所以按照长度的不同来分类会好一些。
长度相同的，就找到不同的那个，比较后面的是不是相同。
长度不同的，找到不同的那个，然后比较长的的后面，和短的的包含当前字符的后面。
对于边界。可以先做主支，再根据主支的条件去做边界。

### 01.06. 字符串压缩
直接遍历一遍。


### 01.07. 旋转矩阵
数学？

### 01.08. 零矩阵
可以用两个数组来存行和列的标识。
因为清过的行和列，就可以跳过不用再去处理了。

### 01.09. 字符串轮转
这个，如果s2是s1旋转的，那么s1一定出现在s2+s2里


### 03.01. 三合一
一个数组来实现三个栈？？怎么可能啊
。。题目看漏了，是还有栈的大小。

### 03.02. 栈的最小值
再维护一个最小值栈，放每次push进来当前的最小值。


### 03.03. 堆盘子
维护List of Stack.
pop永远拿list末尾的
要注意边界值，就是cap<=0

### 03.04. 化栈为队
队列，先进先出
就用两个栈来倒腾。
push就一直push，直到要pop了，就倒到第二个栈
就是第一个栈push，第二个栈pop，但是第二个栈必须是第一个栈倒过来的。


### 03.05. 栈排序
最小元素位于栈顶。
也就是维护一个单调递减的栈
要注意stck的pop和peek栈为空都是会抛异常的。


### 03.06. 动物收容所
用LinkedList, deque来做
注意dequecat的时候，用迭代器来
for(int[] animal : queue)
    queue.remove(animal);













