### 286. 墙与门
可以同时从各个门出发，走一步，被走到的没visit过的点，肯定是最短的。
然后全部走完后后，那些没被visit过的，就是走不通的。
Queue doorQueue;
for each doorQueue:
    go to 4 INF direction, set to currentValue+1, put into doorQueue
 
### 200. 岛屿数量
每块陆地都有可能成为岛屿
然后我觉得这个问题可能可以以把多块连续的陆地看成一块大陆地的方法来做。
但是这样的抽象好像不大好做。
看了题解后，发现是这个思路：
我们遍历找到一个1后，就去对它进行外扩的搜索。
这个搜索的条件是，有相邻的1（然后这里面这个搜索应该是用深度或者广度都可以）。
要注意，搜索过的位置，要设置为0，这样避免下个遍历重复搜索了。
直到没有可以搜索的相邻的1了。就得出了一个岛屿。然后继续上一重循环里的搜索。
===
这里的思路的关键是，一个岛屿，必然是一起一直连着的一些陆地，我们用连连看，把他们消灭。
就可以找出这块陆地。然后这个连连看，可以用广度搜索的方式。

### 752. 打开转盘锁
应该可以用广度优先的算法，把所有的可能性铺开来。
1. 可能性怎么样展开？按位往上加。
2. 什么时候停止？碰见deadend的时候。和碰见结果的时候。
3. 怎么记录这个最小旋转次数？可能要一个（num, count）的序列串，每次往上加1.
这样还有点问题，因为它不是只increase，是还decrease的，并且还得记录，哪些字符串，是visit过的
这个感觉有点麻烦。如果用hashset的话，又感觉太浪费。因为可能性感觉比较多。
其实如果用广度优先的话，这个最小旋转次数其实就是广度优先的层数。
所以不需要这个（num, count），只需要维护层数的信息。















