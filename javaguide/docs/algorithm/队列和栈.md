### 286. 墙与门
可以同时从各个门出发，走一步，被走到的没visit过的点，肯定是最短的。
然后全部走完后后，那些没被visit过的，就是走不通的。
Queue doorQueue;
for each doorQueue:
    go to 4 INF direction, set to currentValue+1, put into doorQueue
 
### 200. 岛屿数量
每块陆地都有可能成为岛屿
然后我觉得这个问题可能可以以把多块连续的陆地看成一块大陆地的方法来做。
但是这样的抽象好像不大好做。
看了题解后，发现是这个思路：
我们遍历找到一个1后，就去对它进行外扩的搜索。
这个搜索的条件是，有相邻的1（然后这里面这个搜索应该是用深度或者广度都可以）。
要注意，搜索过的位置，要设置为0，这样避免下个遍历重复搜索了。
直到没有可以搜索的相邻的1了。就得出了一个岛屿。然后继续上一重循环里的搜索。
===
这里的思路的关键是，一个岛屿，必然是一起一直连着的一些陆地，我们用连连看，把他们消灭。
就可以找出这块陆地。然后这个连连看，可以用广度搜索的方式。

### 752. 打开转盘锁
应该可以用广度优先的算法，把所有的可能性铺开来。
1. 可能性怎么样展开？按位往上加。
2. 什么时候停止？碰见deadend的时候。和碰见结果的时候。
3. 怎么记录这个最小旋转次数？可能要一个（num, count）的序列串，每次往上加1.
这样还有点问题，因为它不是只increase，是还decrease的，并且还得记录，哪些字符串，是visit过的
这个感觉有点麻烦。如果用hashset的话，又感觉太浪费。因为可能性感觉比较多。
其实如果用广度优先的话，这个最小旋转次数其实就是广度优先的层数。
所以不需要这个（num, count），只需要维护层数的信息。


### 279. 完全平方数
广度优先，层最短。
维护层数。


### 155. 最小栈
最小栈的话，可能就要额外维护一个额外的最小值栈和元素栈平行的。

### 20. 有效的括号
一是必须成对出现
二是嵌套关系也要对
可以用消消乐的方法。有相连的配套的就消掉。
问题：怎么来表示配套
这个匹配可以直接用map来装对应的。
        Map<Character, Character> pairs = new HashMap<Character, Character>() {{
            put(')', '(');
            put(']', '[');
            put('}', '{');
        }};


### 739. 每日温度
因为是要得到到更高的温度需要等待的天数
所以可以维护一个递减栈，碰见更大的后，就把里面比它小的吐出来，作为结果。
但是怎么来记录每个温度的位置呢。就是这个温度和比它高的温度的距离。
可以在栈里记录index，而不记录值，值的话通过index去数组里面索引



### 150. 逆波兰表达式求值
就是用一个栈，把东西放进去，遇到操作符，就弹出两个数去算，把结果作为操作数再压栈

### 200. 岛屿数量
用深度优先搜索的算法来做。
剩下的思路跟广度优先一样，就是按照规则把能找到的东西都找到。
直到没有可延申的了，就是一个岛屿。

### 494. 目标和
深度搜索优先
对于每一个数字，都有两种选择，就遍历。
要注意这种的关键点是，没走到最后你是不知都结果的。
所以其实是每条路径都要走到最后的。
并且要注意0，这个是有两种可能，+0和-0都是要的。
所以怎么统一这个思路，把代码写好，是比较要考虑的。


### 94. 二叉树的中序遍历
中序是左中右。
然后因为栈是先进后出，所以整个入栈的时候，要按相反的顺序
也就是右，中，左。
有右先保存右，然后把自己放进去，然后去循环处理自己的左边。
只有当自己是叶子节点，才打印
需要维护一个visited Set，来保存谁是已经打印过的。
==========怎么感觉这题好像还是不懂。
等过段时间再复习一遍




### 232. 用栈实现队列
用两个栈实现队列
stack，helper
push的话就一直往stack放
遇到pop，就把stack往helper倒，从helper里面pop。（如果helper里面有数直接pop helper）
需要注意的是stack的判空

## 225. 用队列实现栈
1,2,3,4,5
1，2，3，4
这个跟用栈实现队列还有点不一样
也是两个队列倒着来，但是这个倒着是为了拿到当前队列中的最后一个。
所以下次加，还得加在有数据的那个队列。
所以queue1，queue2
然后还有两个reference，current和idle来指示当前active的那个queue。


### 394. 字符串解码
从左往右压栈，当发现了】就开始出栈计算，计算结果再压栈
也就是说，碰见右括号就要计算。
而且这个计算结果，最好用string去存，不用char。可以避免需要二次计算。
=======
这里面的细节还挺多的。
要做好消消乐一个很重要的地方是，得把消消乐做成算法。
每次往stack里面放东西的时候，就会触发这个算法。
这样逻辑就很清晰，也很好看。
========
再更正一下，其实需要消消乐的也就是在碰到]的计算之后。要跟前面的再消一下

### 542. 01 矩阵
广度优先
所以必然涉及到queue
然后还要visited
有这两个就完事

### 733. 图像渲染
什么意思啊
0 0 
0 0
=======
image = [[1,1,1],[1,1,0],[1,0,1]]
本来以为，[1,1,1]是idx[1,1]上面的颜色值是1
神经病啊！人家[1,1,1]是第一排的三个颜色值！！
我觉得这题的话做深度优先和广度优先都是一样的
因为深度优先比较不熟就做一下深度优先把。
=======深度优先
深度优先还是从一棵树开始看起，
对于这种图来说，或者说矩阵。即使是深度优先，
好像也要有visited这个东西。不然就会一直来回扩展。没有尽头
也就是说，要做成树，一定要是去环化的。
去环化，也就是只能通过visited来记录
========请注意，这里不需要通过visited来去环化
因为，只要实时地刷上new Color，其实这个已经是一个隐形的visited.
也就是说，那些是newcolor的，都是viist过的。

### 841. 钥匙和房间
这个好像挺简单的，就广度优先，
然后最后看visited是不是全部都是true。


### 133. 克隆图
其实就是遍历，遍历的中间就顺便新建嘛
但是这里有一些要注意的问题
一是要防重复，用visited
二是，新建的时候，它的那些连接点，如果是已经被遍历过的，是得去找他们的引用，不能直接新建。不然就会丢失连接
所以对于已经被遍历过的，还得给存起来。并且要是新节点，旧节点，和之间的联系
==========
说不清楚，得多做。dfs得多做。
现在可能是还一看就会，一做就废。
```
class Solution {
    Map<Node, Node> map = new HashMap();
    public Node cloneGraph(Node node) {
        if(node == null) return null;
        if(map.containsKey(node)){
            return map.get(node);
        }
        Node newNode = new Node(node.val);
        map.put(node, newNode);
        for(Node neighbor : node.neighbors){
            newNode.neighbors.add(cloneGraph(neighbor));
        }
        return newNode;
    }
}
```




















