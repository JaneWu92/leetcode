### 286. 墙与门
可以同时从各个门出发，走一步，被走到的没visit过的点，肯定是最短的。
然后全部走完后后，那些没被visit过的，就是走不通的。
Queue doorQueue;
for each doorQueue:
    go to 4 INF direction, set to currentValue+1, put into doorQueue
 
### 200. 岛屿数量
每块陆地都有可能成为岛屿
然后我觉得这个问题可能可以以把多块连续的陆地看成一块大陆地的方法来做。
但是这样的抽象好像不大好做。
看了题解后，发现是这个思路：
我们遍历找到一个1后，就去对它进行外扩的搜索。
这个搜索的条件是，有相邻的1（然后这里面这个搜索应该是用深度或者广度都可以）。
要注意，搜索过的位置，要设置为0，这样避免下个遍历重复搜索了。
直到没有可以搜索的相邻的1了。就得出了一个岛屿。然后继续上一重循环里的搜索。
===
这里的思路的关键是，一个岛屿，必然是一起一直连着的一些陆地，我们用连连看，把他们消灭。
就可以找出这块陆地。然后这个连连看，可以用广度搜索的方式。

### 752. 打开转盘锁
应该可以用广度优先的算法，把所有的可能性铺开来。
1. 可能性怎么样展开？按位往上加。
2. 什么时候停止？碰见deadend的时候。和碰见结果的时候。
3. 怎么记录这个最小旋转次数？可能要一个（num, count）的序列串，每次往上加1.
这样还有点问题，因为它不是只increase，是还decrease的，并且还得记录，哪些字符串，是visit过的
这个感觉有点麻烦。如果用hashset的话，又感觉太浪费。因为可能性感觉比较多。
其实如果用广度优先的话，这个最小旋转次数其实就是广度优先的层数。
所以不需要这个（num, count），只需要维护层数的信息。


### 279. 完全平方数
广度优先，层最短。
维护层数。


### 155. 最小栈
最小栈的话，可能就要额外维护一个额外的最小值栈和元素栈平行的。

### 20. 有效的括号
一是必须成对出现
二是嵌套关系也要对
可以用消消乐的方法。有相连的配套的就消掉。
问题：怎么来表示配套
这个匹配可以直接用map来装对应的。
        Map<Character, Character> pairs = new HashMap<Character, Character>() {{
            put(')', '(');
            put(']', '[');
            put('}', '{');
        }};


### 739. 每日温度
因为是要得到到更高的温度需要等待的天数
所以可以维护一个递减栈，碰见更大的后，就把里面比它小的吐出来，作为结果。
但是怎么来记录每个温度的位置呢。就是这个温度和比它高的温度的距离。
可以在栈里记录index，而不记录值，值的话通过index去数组里面索引



### 150. 逆波兰表达式求值
就是用一个栈，把东西放进去，遇到操作符，就弹出两个数去算，把结果作为操作数再压栈

### 200. 岛屿数量
用深度优先搜索的算法来做。
剩下的思路跟广度优先一样，就是按照规则把能找到的东西都找到。
直到没有可延申的了，就是一个岛屿。

### 494. 目标和
深度搜索优先






