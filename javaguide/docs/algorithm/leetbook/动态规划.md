669 coin change -> lintcode

### 53. 最大子序和
具有最大和的连续子数组
f(n) = max(f(n-1), a[n])  -> 错误，人家要的是**连续**的的数组
f(n)表示的是n个数中，最大的连续子数组和。而不是以n结尾的，最大的子数组和
f(n)应该是等于，包含以n为结尾的，和不包含以n为结尾的里面，比较大的那个。
但是因为要是连续的，怎么判断f(n-1)到底取了以n-1为结尾，还是没取呢。
==========分隔符
因为以上状态无法确定，所以我们要换一个思路。
f(n)用来表示以n为结尾的，最大的子数组和。
然后最后的答案就是max(dp[i])
f(n) = max(a[n], a[n]+f(n-1))


### 300. 最长上升子序列
最长的上升子序列。不用连续
f(n)代表以n为结尾并且包含n的最长子序列的长度。
f(n) = max(f(i))+1 a[i]<a[n]
答案是dp的最大


### 673. 最长递增子序列的个数
维护长度和个数这两个状态。
f(n)代表以n为结尾的递增子序列。
f(n) = 
（f(n-1..i..0)中长度最长的递增子序列，并且a[n]>a[i]）
然后长度加上 pre,个数不变。

这里面有一个重要的点是，重复的问题。
在求（f(n-1..i..0)中长度最长的递增子序列，并且a[n]>a[i]）的时候
如果有更长，就reset这个count变成1
如果是跟当前相等，那是在本来的count上加1（请注意，不是1，应该是dp之前状态的count）


### 354. 俄罗斯套娃信封问题
最多能有多少个信封形成套娃
f(n)是以n为最后一个信封的套娃数量
f(n)等于1+ 前面所有比他小的数量的最大值
哦这题的一个难点是，不计较顺序。
所以我觉得可以先按width排序一下，再做。


### 152. 乘积最大子数组
乘积最大连续子数组
f(n) = max(f(n-1)*a[n], a[n])
这个问题有点不一样，f(n)不能由f(n-1)推出来。
====因为有正负，所以没有最优子结构
所以每一个都要保留两个状态，最大和最小。
因为都有可能对结果有贡献


### 918. 环形子数组的最大和
应该是两倍的当前数组组成一个新数组，然后再做一样的操作
abcde abcde
f(n)是max(a[n], f(n-1))
应该是从第2个N开始算，就是第二个abcde
Kadane算法：不确定具体步骤
但是这里有一个是说，如果这个最大和是跨数组的，
那它被环留下的子数组，会是不跨数组的最小和。不知道是为什么

### 面试题 17.24. 最大子矩阵
应该是把一维的变成二维的了。
是最大和子序列的升维版本。
？？？


### 198. 打家劫舍
相邻的房屋是不能偷的。
也就是每个位置都存在两种可能，能偷或者不能，并且这个结果会影响到下一个的结果
f(n)代表的是以当前这个位置为结尾的最高的收入。
f(n)是由a[n]+ Max(f(n-2 ... i ..0))
===========
有问题啊。这里好像可以是另外一种思路。
就是f(i)是代表对于前i间房偷窃的最好方案。
它包括两种：
第i间要偷：f(i) = a[i] + f(i-2)
第i间不偷: f(i) = f(i-1)
所以f(i) = max(上面两者)
===========
好像这种问题以上两个选择都是可以的。但是具体如何区分，待查


### 213. 打家劫舍 II
房屋围成一圈。
也就是说第一个和最后一个，只能偷窃一个。
可以按照单排的来算。
然后选最大的，最后一个和第一个没有一起出现过的。
但是它会恰巧包含我们想要的解吗，就是第一和最后不重复出现
我觉得未必。因为按照我们的做法，得出的结果是，以n为结尾的，最大的选择。选择只有一个，要么带1，要么不带1。
所以我觉得其实可以在f最后一个的时候，显式的去掉以1为结尾的。
但是也是不对的，因为我们要排除的，不是以1为结尾的，是包含1的。
所以要用另外的思路。
分成三类：有1无尾，无1有尾，无1无尾
在其中选最大，应该就对了。
但是这里面有可以优化的部分吗。感觉相同的做三次有点傻（写个子函数不就行了。。）。


### 740. 删除与获得点数
居然是打家劫舍的变种。太隐蔽了。
新建数组，把数字记录在数组下标的信息上。
新数组的a[i]，表示的是原数组上i出现的个数。
题目变成，新数组相邻的数字不能选，然后计算最大的字串和。
这个和是i*a[i]的和。
===========
参考上面打家劫舍


### 1388. 3n 块披萨
这题就是循环打家劫舍的变种。
但是打家劫舍只是相邻的不能选
这里的也是相邻的不能选。并且在可选总数上是有限制的。
因为其实所有东西是三个人分。
。。。。以后再看


### 873. 最长的斐波那契子序列的长度
https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/
这个题目
最优子结构是，f(i) = 1 + f(<i)所有的最大，并且，a[i]=子结构里最后两个数的和
怎么保存这个状态。dp[][]，两个数，保留数组的下一个，和这个数组的长度
===========
这里有一个问题，就是这个最优子结构，只能保持一个序列，但是可能有很多序列都是一样的长度，但是有机会和现在这个组成更长的，被丢弃了。
所以这个方法是不行的。
===========
dp[(3,5)], dp[(2,3)]
这个就是所谓的要记录两个状态。
这里的重点就是，要有两个数，才能准确锚定一个斐波那契子序列。
===========
对于这种需要两个数字才能确定状态的。状态矩阵就用dp[][]
dp[i][j]代表以i，j为结尾的斐波那契子序列的最长长度。
这样就跟dp[]的一模一样了
dp[i][j] = dp[ a[j]-a[i] 这个值 的index ][i]


### 1027. 最长等差数列
https://leetcode-cn.com/problems/longest-arithmetic-subsequence/
dp[i][j]表示以i，j为结尾的等差子序列的长度
=========
审题要审清楚了。人家数列是不能打乱顺序的。
并且，数组里的数字，还是可以重复的。
基于“重复”这个因素，hashmap里的数字要一步一步跟着计算的步骤一边跟着添加。



### 368. 最大整除子集
先排序。
然后f(n)和子结构的关系，除了要记录长度，还要记录里面所有的数据。
因为这样才能知道和a[n]到底是不是整除的。
应该先考虑，这个所有元素两两相整除是不是有隐藏的副作用。
哦！！果然有！
如果abc是满足这个条件的，那我新来的d，如果能够整除c，就ab肯定也能整除。
所以最长个数的话，就按照老套路。
但现在它要返回的是具体的结果。这个怎么保存。--> 就直接硬开辟空间保存呗。




### 剑指 Offer 48. 最长不含重复字符的子字符串
首先，看到“最长”字样，有可能跟动态规划有关。
分析题目，从暴力解入手。
假设解是(i,j)，也就是说其他的字符串在(i,j)种肯定出现，并且(i,j)完全不重复，并且找不到比(i,j)更长的满足条件的解
可以用状态变量int dp[][]来表示以i，j为两端的，最长的无重复子字符串的长度。
但是这样的话，f(i,j) 和 f(i,j-1)的关系，其实是没办法确定的。
所以换一种用boolean dp[][]来表示以i，j为两端的，是不是无重复的字符串。这样结果可以由遍历所有true的，取出j-i最大的数
然后f(i,j+1) = j+1的字符去查看是不是跟i，j的字符有重复，有就是false，没有就是true
=========以上这个方法在字符串非常大的时候会超出内存限制
所以要考虑状态压缩的问题
其实f(i,j)只需要f(i,j-1)的状态，并且这个状态是没有断层的，完全可以压缩成只记两个状态就行了。
这个方法通过倒是通过了。但是时间复杂度只击败5%
应该还有更好的办法，就是用hashset来保存前面的字符，来做重复的判断。
只不过是，这个hashset的状态跟distinct一样，是一直要去维护改变的。
==========用了hashset竟然也只是击败5%！
看了题解的方法，它做了一个优化，就是如果发现是有重复的，其实下一个start的索引就得从当前idx开始了。（错误）
是从找到的之前的那个重复的索引的下一个位置。
因为start从之前开始的，都不可能是最优解了。
还有一个优化点是，可以直接维护一个(char，idx)的hashmap，
这样通过找当前这个char在hashmap中的idx，其实就可以逆向推出，跟之前的那个子串是不是完全不重复
并且这里还不用记录上一个相邻的子串是重复还是不重复的。
相当于一个是正着推，一个是反着推。
这么说也不准确。应该是说，它是直接每次都去找不重复的。
根本不会去记录那些重复的。
============
总结一下，就是动态规划的状态压缩吧总体来说。
其实它是双指针。只是说双指针太custom了。不够思路统一。













