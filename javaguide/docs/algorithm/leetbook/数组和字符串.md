

724. 寻找数组的中心索引
可以这么做，另外定义两个数组，分别存放从左到右和从右到左的和。
然后从这两个结果中，找idx左右两边的位置，相等的那个，返回
===========看了下题解
，，有一个东西漏了，要说相等。
先算总和，然后再
leftsum + rightsum + nums[i] = Sum
2*leftSum should equalto (Sum - nums[i])
========后来想了一下，其实计算量一样。是空间换时间。
但其实好像也没换时间。。。。
whatever，代码写起来是短了好多




35. 搜索插入位置
就是找到一个  left < current < right的位置



56. 合并区间
用两个指针，来维护当前要重叠的range idx。然后写进结果集
挺多边界条件要注意的。
==============看了题解才发现题目本来是没有说排序的。。照着排序的前提居然也对了
要先排序。
Arrays.sort(intervals, (o1, o2) -(o1[0] == o2[0] ? o1[1] - o2[1] : o1[0] - o2[0]));
然后对于边界条件的判定这部分是比较弱的，证明整个思路没有非常清晰。
要重新训练。
=============这题怎么回事啊，还有一种情况，是first[1]比second[0]和second[1]都大
其实用两两比较更新的做法会更好。
两两比较，能吃就吃。不能吃了就把现在的加入结果集。再从下一个开始，去吃
这样的思路会非常的清晰明了
```
        tmpTuple = intervals[0];
        for(int i = 0; i < N; i++){
            //如果可以吃，就吃
            if(tmpTuple[1] >= intervals[i][0]){
                tmpTuple[1] = Math.max(tmpTuple[1], intervals[i][1]);
            }else{
                rList.add(tmpTuple);
                tmpTuple = intervals[i];
            }
        }
```


面试题 01.07. 旋转矩阵
原地旋转
旋转九十度的本质是什么
=======转90度在数学上怎么计算
应该是
第一排第m个 =》 倒数第一列第m个
第二排 =》 倒数第二列
第n排  =》 倒数第n列
N=3
1，2 =》  0,1 
i,j
N-1-j,  N-1-i
=================
这样有问题，因为是原地，所以本来要处理的第一行，结果第一行有些数据在你本地转换的时候已经被修改了。。。
=================
比较好理解的是，
先i，j =》 j，i
然后每行reverse。。



面试题 01.08. 零矩阵
做了太久了这题，错了好多小细节



498. 对角线遍历
右上就是 -1,+1,
左下就是 +1,-1
这一行结束要到下一行就是
?????先不做。


14. 最长公共前缀
维持一个idx来记录相同的位置






















