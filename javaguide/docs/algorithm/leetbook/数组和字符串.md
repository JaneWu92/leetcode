

724. 寻找数组的中心索引
可以这么做，另外定义两个数组，分别存放从左到右和从右到左的和。
然后从这两个结果中，找idx左右两边的位置，相等的那个，返回
===========看了下题解
，，有一个东西漏了，要说相等。
先算总和，然后再
leftsum + rightsum + nums[i] = Sum
2*leftSum should equalto (Sum - nums[i])
========后来想了一下，其实计算量一样。是空间换时间。
但其实好像也没换时间。。。。
whatever，代码写起来是短了好多




35. 搜索插入位置
就是找到一个  left < current < right的位置



56. 合并区间
用两个指针，来维护当前要重叠的range idx。然后写进结果集
挺多边界条件要注意的。
==============看了题解才发现题目本来是没有说排序的。。照着排序的前提居然也对了
要先排序。
Arrays.sort(intervals, (o1, o2) -(o1[0] == o2[0] ? o1[1] - o2[1] : o1[0] - o2[0]));
然后对于边界条件的判定这部分是比较弱的，证明整个思路没有非常清晰。
要重新训练。
=============这题怎么回事啊，还有一种情况，是first[1]比second[0]和second[1]都大
其实用两两比较更新的做法会更好。
两两比较，能吃就吃。不能吃了就把现在的加入结果集。再从下一个开始，去吃
这样的思路会非常的清晰明了
```
        tmpTuple = intervals[0];
        for(int i = 0; i < N; i++){
            //如果可以吃，就吃
            if(tmpTuple[1] >= intervals[i][0]){
                tmpTuple[1] = Math.max(tmpTuple[1], intervals[i][1]);
            }else{
                rList.add(tmpTuple);
                tmpTuple = intervals[i];
            }
        }
```


面试题 01.07. 旋转矩阵
原地旋转
旋转九十度的本质是什么
=======转90度在数学上怎么计算
应该是
第一排第m个 =》 倒数第一列第m个
第二排 =》 倒数第二列
第n排  =》 倒数第n列
N=3
1，2 =》  0,1 
i,j
N-1-j,  N-1-i
=================
这样有问题，因为是原地，所以本来要处理的第一行，结果第一行有些数据在你本地转换的时候已经被修改了。。。
=================
比较好理解的是，
先i，j =》 j，i
然后每行reverse。。



面试题 01.08. 零矩阵
做了太久了这题，错了好多小细节



498. 对角线遍历
右上就是 -1,+1,
左下就是 +1,-1
这一行结束要到下一行就是
?????先不做。


14. 最长公共前缀
维持一个idx来记录相同的位置



5. 最长回文子串
遇到题目，先想暴力解
从结果来说，要有i，j来指示最长回文子串的头尾
暴力解的意思来说，就是我可以遍历所有的i，j的可能性，看它是不是回文
在是的里面，找出最长的
这个是暴力解。
暴力解的问题是，很多都重复算。
只要解决出重复算的这部分工作，就可以找到正确的我们期待中的解。
然后解决重复算这部分的问题，我们想到可以空间换时间，也就是动态规划。
但是问题在于，回文子串不是那种，解是可以通过一个一个加出来的。
回文的性质，当加入一个新的字符，可能会被完全的破坏。
这个的意思是，子答案的信息是无法利用的。
==========看了下题解，你猜我看到什么
我只想到了可以每次加一端，没想到可以每次加两端！！！
回文的性质就是，在左右两边再加上同样的字符，就还是回文!否则不是
唉呀原来是这样来利用“子答案”信息的。是我思维定势了。
===========有一点很需要注意的是
对做动态规划的东西来说，很重要的一点是，当我再算长一点的解时，我参考过去的短解
这个短解，一定要是已经算过的。
所以在做动态规划的顺序很重要。
```
        // for(int i = 0; i < N; i++){
        //     for(int j = i+1; j < N; j++){
        //         boolean same = s.charAt(i) == s.charAt(j);
        //         if(j-i == 1){
        //             if(same) dp[i][j] = true;
        //         }else{
        //             dp[i][j] = same && dp[i+1][j-1];
        //         }
        //     }
        // }
        for(int len = 2; len <= N; len++){
            for(int i = 0; i < N; i++){
                int j = i + len - 1;
                if(i >= N || j >= N) break;
                boolean same = s.charAt(i) == s.charAt(j);
                if(len == 2) dp[i][j] = same;
                else dp[i][j] = same && dp[i+1][j-1];
            }
        }
```



151. 翻转字符串里的单词
普通解法就是，把string加到list里，然后，倒序输出
```
        s = s.trim();
        List<String> wordList = Arrays.asList(s.split("\\s+"));
        Collections.reverse(wordList);
        return String.join(" ", wordList);
```
或者可以用指针法，从后面开始遍历，遇到空格，就定住，把当前单词输出到结果集
==========哇你别说，
就这么简单一个题目，你如果对你自己定义的变量的逻辑和定位不够清除的话，你就是写都写不明白。
===========
本来的思路是，定义start，end，然后for(int i from N-1 to 0)
去在遍历全部的过程中，不断更新start end并且去刷新
搞了好久没搞好。
现在想想这种思路太复杂了，理解起来和实现起来很困难。
可以换一种思路。
就是一个right指针，一个left指针。
right指针先while走到不是空格的地方，left再从它的位置走到碰到空格的地方，把东西记录下来
然后，right从left再开始走
这思路多清楚。
=================哇这个边界条件太难搞了。。。。太难写了还没写出来
哇这种题目的边界判断好难啊
就是，right越不越界，left越不越界，这种太繁琐了，一团乱。
=============方法？
可以采用一个一个分析的法子，就跟tree的判空一样，if(left != null)开始做，if(right != null)开始做
这样的线条可能会比较清楚一点
```
        while(true){
            while(s.charAt(right) == ' '){
                right--;
                if(right < 0) break;
            }
            if(right < 0) break;
            left = right;
            while(s.charAt(left) != ' '){
                left--;
                if(left < 0) break;
            }
            res = res+s.substring(left+1, right+1) + " ";
            if(left == -1) break;
            right = left;
        }
```
没应用到什么方法，总体的就是要时刻注意判空条件



561. 数组拆分 I
min的总和最大
应该就是尽量把差不多的组合再一起
那我觉得排序一下，然后按顺序两两组合就好了把。



167. 两数之和 II - 输入有序数组
左右两个指针，和跟target比，小了的话就左进，否则右退。


27. 移除元素
两个指针，一个指着新数组，一个指着要搬迁的老数据。


485. 最大连续1的个数
两个指针，一个指着1的，一个继续走，直到碰到0.
维护连续大小的max。


209. 长度最小的子数组
动态规划就是dp[][]
dp[i][j]的值表示的是子数组子串大不大于s，或者说子数组i,j的和
然后在所有true的里面，选择j-i最小的。时间复杂度是O(n^2)
照理来说，没有可压缩的计算了啊
============看了下题解。
唉呀我去
上面的那个动态规划可压缩计算的部分在于，如果i，j已经大于sum了，你i，j+1肯定就不用试了啊
i，j存在，i，j+1肯定就不会是解了。通过这种方式，来压缩计算。






















