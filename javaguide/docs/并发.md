## cache coherence
* cache coherence
    * 为什么？
        * 在多cpu的情况下，如果多个线程刚好都在多个cpu下，他们从主存中读一个东西后，会缓存在多级缓存中。
        * 各线程在各cpu的缓存中维护他们自己的副本，所以数据会不同步。
        * cache coherence是一种协议，能够解决这种共享变量的同步问题。
    * 需要保证两点
        * write propagation：我这里写了你那里要能看到
        * transaction serialization： 多地的顺序要跟在一地一样
    * 有两种设计思路
        * write invalidate: 如果一个缓存中的数据有新写，其他cpu监听到，缓存中相对应的数据都会变成invalid，这造成它要到主存读，也就读到了新的数据
        * write update: 如果一个缓存中的数据有新写，其他cpu监听到，它会相应地更新其他缓存中的数据。
        
## memory barrier
* 硬件级别的(cpu指令集级别)一种指令，可以让cpu保持指令的执行顺序。
* barrier就相当于一个屏障，你想调整指令的顺序，不能跨越屏障。所以比如你在指令a和指令b中间加了一个barrier，指令b就不可能跑到指令a前面先执行。
```aidl
Processor #1:
while(f == 0);
// Memory barrier required here
print x;

Processor #2:
x = 40;
// Memory barrier required here
f = 1;
```

## volatile
* volatile和cache coherence的关系
    * 问题，既然有了cache coherence，我还要volatile做什么？
    * cache coherence是一种能力。就是你要用的时候可以去用。而不是它全部给你用上了。那多级缓存还有个鬼用。
    * cache coherence是操作系统提供的一种功能。volatile在设计的时候，可以用OS提供的这个API，来实现cache coherence。
    * 就像核武器，不是我造出来了就天天在打仗了。而是放着，我需要用的时候我就拿出来用。
* volatile的功能和实现
    * 指令重排的禁止
        * volatile的变量的access(read/write)，都会插入membar,这样指令就可以防止重排，多线程下就不会产生一些问题。
    * 线程间的内存可见性
        * volatile的变量的access(read/write)，都会保证缓存一致性。所以不会造成线程间看不到对方的latest write。
        * 也就是说，每次读写都会读写到最新值。
        * 实现。根据硬件架构的不一样，应该有不同的实现。
            * 比如说可以write update。每次写，都写到主存并且其他cache也刷新。
            * 或者说write invalidate。每次写，都写到主存并且让其他cache的变成invalid。这样其他invalid的cache要读的话，都会重新从主存读取。
    
## CAS
* implementation
    * in cpu arch level: lock cmpxchg(in x86 arch)
    
    
## cmpxchg
* https://wiki.osdev.org/Atomic_operation
* in single processor single core, 
    * if an operation is implemented in a single cpu instruction is always **atomic**
    * if it required multiple cpu instruction, it will be atomic if it **disable interrupt**
* in multiprocessors or multicore,
    * to get atomic, you need to assert **"LOCK"** signal on the bus
* 问题
    * cmpxchg和cache coherence的关系
        * 先说single core底下是atomic的，okay如果是single core，也不存在cache竞争的情况，也不存在被打断的情况。所以没问题。
        * 再说multiprocessor底下
        
    
    
    
    
    
    
    
    
    
    
    
    
    
    