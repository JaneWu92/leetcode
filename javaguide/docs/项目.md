* 为什么需要单例模式
    * 我觉得应该有两个方面
        * 一个是整个JVM只能有一个
            * 比如一些资源类的
        * 一个是只有一个就够了
            * 比如spring里你配的serviec类，其实就是单例。
            * 为什么单例，因为没有状态，你用一个类就够用了
    * 单例只有一个，必然涉及到共享的问题。多线程下会不会有问题
        * 如果没有状态，就有问题
        * 如果有状态。那你相关的方法一定要是线程安全的
        
* 什么时候用static method
    * 可以用排除法
        * 如果你觉得一个方法，跟一个instance没什么关系。
        * 也就是说，即使你没有任何实例，我这个方法都是有意义的。
        * 那这时候就要考虑用static method
         
* 写一个单例模式
```
class MyClass{
    //属性设置成private，因为不想让别人访问
    //设置成static，因为单例，整个JVM只需要有一个
    //要加volatile。避免cpu指令重排，还没实例化成功先赋值了instance的地址。
    //这样其他线程可能就先拿了一个空
    private static volatile MyClass instance;
    //默认构造函数设置成private
    //使别人没办法直接new
    private MyClass(){
    }
    //设置成static，因为整个函数跟具体的实例没有关系
    public static MyClass getInstance(){
        //先不上锁，判断一下instance是不是可以使用
        //因为使读，不上锁即可以提高性能，又可以当可用就直接用
        if(instance == null){
            //同步锁来保证只有一个线程在做事
            //要锁住class而不是实例，因为我在一个静态方法里面
            synchronized(MyClass.class){
                //里面还要再判一次空，因为在你第一次判空和拿到锁之前，还有好长一段时间
                //可能已经有另外一个线程进来把你的instance已经给初始化了
                //所以同步块外的判断，在同步块里面，永远要重新判断一次
                if(instance == null){
                    instance = new MyClass();
                }
            }
        }
        return instance;
    }

}
```
        
        
        
        
        
        
        
        
        
        
        
        
        
        