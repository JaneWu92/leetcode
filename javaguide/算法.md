## Sliding windows
### 424. 替换后的最长重复字符
* 这里面比较不好理解的是，为什么historyMax不用每次精准地去维护
* 没人说得清楚还
* 但是这个historyMax是historywindow的max，不是currentwindow的max，所以它有可能是虚高的，那通过它来判断，有什么用啊！！
```aidl
// 硬分析一场，
// 不由分说，先看这个right的更新
// 然后判断当下这个window要不要左边缩回来。要缩就一直缩，缩到满足条件了，再继续right++
// 这里的max_length, 要有一个变量来维护
// 这里的maxc_count，不用做那么精准。---》 这个还没有理解透
class Solution {
    public int characterReplacement(String s, int k) {
        int left=0, max_count=0, max_length=0, len=s.length();
        int[] letters = new int[26];
        for(int right=0; right<len; right++){
            char c = s.charAt(right);
            letters[c-'A']++;
            max_count = Math.max(max_count, letters[c-'A']);
            while(right-left+1> k+max_count){
                char l_c = s.charAt(left);
                letters[l_c-'A']--;
                left++;
            }
            max_length = Math.max(max_length, right-left+1);
        }
        return max_length;
    }
}
```

## 数组，双指针
### 15. 三数之和
* 三重循环一下搞定，时间复杂度N^3
* 这个时间复杂度呢，已经可以做随便找3个数，这件事情。但是本题中，三个数字之间是有关系的，和的关系。
* 所以如果用上面这个算法，是浪费了这个“和”的信息。
* 然后我们就来看这个“和”的信息怎么样能够利用起来。
* 先把第一重的固定下来，然后第二重第三重分别从最左最右开始，因为一个只能增，一个只能减，它的移动的规律就很明显了。直到他们相撞前能碰见彼此。
* 还有一点是避免重复。就是第一重和第二重，如果和之前一样，就不用再写了
```aidl

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        if(n < 3) return list;
        for(int i = 0; i< n-2; i++){
            // 这里是为了避免重复
            // 像 2，2，。。。。第二个2解出来的解，肯定是第一个2已经解过了的。毋庸置疑。是子集，所以不用管
            if(i>0 && nums[i] == nums[i-1]) continue;
            int left = i+1, right = n-1, sum = 0-nums[i];
            while(left < right){
                // 如果sum same，就加进list里，然后再left++, right--继续
                // 如果sum大，left++继续
                // 如果sum小，right--继续
                if(left != i+1 && nums[left] == nums[left-1]){
                    left++;
                    continue;
                }
                int tmp = nums[left] + nums[right];
                if(tmp == sum){
                    Integer[] arr = new Integer[]{nums[i], nums[left], nums[right]};
                    List<Integer> l = new ArrayList<Integer>(Arrays.asList(arr));
                    list.add(l);
                    left++;
                    right--;
                }else if(sum > tmp){
                    left++;
                }else if(sum < tmp){
                    right--;
                }
            }
        }
        return list;
    }
}
```
## 回溯
### 46. 全排列
* 就是最朴素的dfs
```aidl
// 深度优先：for loop，第一层，先选取1，然后后面跟其他排列
// 这个其他排列，还是深度优先，跟第一层一样，遍历选取，然后后面再跟其他排列
// 但现在这个问题是，这个结果和参数要怎么传递。
// 一般来说，就是
import java.util.*;
import java.util.stream.Collectors;

class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<Integer> list = Arrays.stream(nums).boxed().collect(Collectors.toList());
        Integer[] arr = list.stream().toArray();
        return dfs(list);
    }

    List<List<Integer>> dfs(List<Integer> nums){
        List<List<Integer>> res = new ArrayList<>();
        if(nums.size() == 1){
            res.add(nums);
            return res;
        }
        for(int i = 0; i < nums.size(); i++){
            // 准备除掉这个i的list
            List<Integer> list = new ArrayList<>();
            for(int k = 0; k < nums.size(); k++){
                if(i != k){
                    list.add(nums.get(k));
                }
            }
            List<List<Integer>> nextList = dfs(list);
            for(int j = 0; j < nextList.size(); j++){
                nextList.get(j).add(0, nums.get(i));
            }
            res.addAll(nextList);
        }
        return res;
    }
    public static void main(String[] args){
        Solution s = new Solution();
        s.permute(new int[]{1,2,3});
    }
}
```
* 回溯
```aidl
// 回溯：
// 你在脑袋里想象那个树状图，只有到叶子节点（也就是这个depth和nums的大小一样的时候），这个才是作为一个结果放进来
// 所以一定要有一个全局的res。这个是每次的递归都共享的。
// 然后就是，这个回溯的过程，我得知道我下一次还有什么可选。这个可以用一个boolean的数组，used来表示。并且这个也是每次递归共享的。
// 然后我还要知道，我正当下的那个已经选择的序列。因为这个是需要在尾部入出，所以可以用stack。这个path，也是全局！

class Solution {
    List<List<Integer>> res = new ArrayList<>();
    boolean[] used;
    Deque<Integer> path = new ArrayDeque<>();
    public List<List<Integer>> permute(int[] nums) {
        used = new boolean[nums.length];
        dfs(nums, 0);
        return res;
    }
    void dfs(int[] nums, int depth){
        if(depth == nums.length){
            res.add(new ArrayList<Integer>(path));
            return;
        }
        for(int i = 0; i < nums.length; i++){
            if(used[i] == true){
                continue;
            }
            path.push(nums[i]);
            used[i] = true;
            dfs(nums, depth+1);
            path.pop();
            used[i] = false;
        }
    }

}
```
* 回溯和朴素的dfs不同的地方
    * 朴素dfs
        * loop现在有的这些个数，比如1,2,3
        * 分别选其中的一个数作为当前的首位。
        * 然后问题就变成，接下去的两个，要怎么排列，这个就是只是再一层的dfs
        * 然后直到最后已经是一个了，就返回。
        * 这里的上面所说的，”接下去的两个“，我用的是最暴力的方法，直接再构造一个数组扔下去做。但是感觉太大费周章了
        * 还是用used[]这种就比较好。
        * 试一下
    * 回溯
    * 唉呀我可能知道了。
        * 这个回溯和朴素dfs的差别就是：
        * 回溯它是全局保留一个状态。这个状态是给所有的无论哪一层的递归使用的，所有它有reset状态这一说。
        * 而朴素dfs，它是每次都构造新的状态往下传，所以根本不用做什么状态的reset。因为人家用的不是全局的。
        
    